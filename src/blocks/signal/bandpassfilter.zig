// @block BandpassFilterBlock
// @description Filter a complex or real valued signal with a real-valued FIR
// band-pass filter generated by the window design method.
//
// $$ y[n] = (x * h_{bpf})[n] $$
//
// @category Filtering
// @ctparam T type Complex(f32), f32
// @ctparam N comptime_int Number of taps
// @param cutoffs struct{f32,f32} Lower and upper cutoff frequencies in Hz
// @param options Options Additional options:
//      * `nyquist` (`?f32`, alternate Nyquist frequency in Hz)
//      * `window` (`WindowFunction`, window function, default Hamming)
// @signature in1:T > out1:T
// @usage
// var filter = radio.blocks.BandpassFilterBlock(std.math.Complex(f32), 129).init(.{ 10e3, 20e3 }, .{});

const std = @import("std");

const Block = @import("../../radio.zig").Block;
const ProcessResult = @import("../../radio.zig").ProcessResult;

const FIRFilter = @import("./firfilter.zig").FIRFilter;

const WindowFunction = @import("../../radio.zig").utils.window.WindowFunction;
const firwinBandpass = @import("../../radio.zig").utils.filter.firwinBandpass;

////////////////////////////////////////////////////////////////////////////////
// Bandpass Filter Block
////////////////////////////////////////////////////////////////////////////////

pub fn BandpassFilterBlock(comptime T: type, comptime N: comptime_int) type {
    return struct {
        const Self = @This();

        pub const Options = struct {
            nyquist: ?f32 = null,
            window: WindowFunction = WindowFunction.Hamming,
        };

        block: Block,
        cutoffs: struct { f32, f32 },
        options: Options,
        filter: FIRFilter(T, f32),

        pub fn init(cutoffs: struct { f32, f32 }, options: Options) Self {
            return .{ .block = Block.init(@This()), .cutoffs = cutoffs, .options = options, .filter = FIRFilter(T, f32).init() };
        }

        pub fn initialize(self: *Self, allocator: std.mem.Allocator) !void {
            // Compute Nyquist frequency
            const nyquist = self.options.nyquist orelse (self.block.getRate(f32) / 2);

            // Generate taps
            const taps = firwinBandpass(N, .{ self.cutoffs[0] / nyquist, self.cutoffs[1] / nyquist }, self.options.window);

            // Initialize filter
            return self.filter.initialize(allocator, taps[0..]);
        }

        pub fn deinitialize(self: *Self, allocator: std.mem.Allocator) void {
            self.filter.deinitialize(allocator);
        }

        pub fn process(self: *Self, x: []const T, y: []T) !ProcessResult {
            return self.filter.process(x, y);
        }
    };
}

////////////////////////////////////////////////////////////////////////////////
// Tests
////////////////////////////////////////////////////////////////////////////////

const BlockTester = @import("../../radio.zig").testing.BlockTester;

const vectors = @import("../../vectors/blocks/signal/bandpassfilter.zig");

test "BandpassFilterBlock" {
    // 129 taps, [0.1, 0.3] cutoffs, ComplexFloat32
    {
        var block = BandpassFilterBlock(std.math.Complex(f32), 129).init(.{ 0.1, 0.3 }, .{});
        var tester = try BlockTester(&[1]type{std.math.Complex(f32)}, &[1]type{std.math.Complex(f32)}).init(&block.block, 1e-6);
        try tester.check(2, .{&vectors.input_complexfloat32}, .{&vectors.output_taps_129_cutoff_0_1_0_3_complexfloat32}, .{});
    }

    // 129 taps, [0.4, 0.6] cutoffs, 3.0 nyquist, Bartlett window, ComplexFloat32
    {
        var block = BandpassFilterBlock(std.math.Complex(f32), 129).init(.{ 0.4, 0.6 }, .{ .nyquist = 3.0, .window = WindowFunction.Bartlett });
        var tester = try BlockTester(&[1]type{std.math.Complex(f32)}, &[1]type{std.math.Complex(f32)}).init(&block.block, 1e-6);
        try tester.check(2, .{&vectors.input_complexfloat32}, .{&vectors.output_taps_129_cutoff_0_4_0_6_nyquist_3_0_window_bartlett_complexfloat32}, .{});
    }

    // 129 taps, [0.1, 0.3] cutoffs, Float32
    {
        var block = BandpassFilterBlock(f32, 129).init(.{ 0.1, 0.3 }, .{});
        var tester = try BlockTester(&[1]type{f32}, &[1]type{f32}).init(&block.block, 1e-6);
        try tester.check(2, .{&vectors.input_float32}, .{&vectors.output_taps_129_cutoff_0_1_0_3_float32}, .{});
    }

    // 129 taps, [0.4, 0.6] cutoffs, 3.0 nyquist, Bartlett window, Float32
    {
        var block = BandpassFilterBlock(f32, 129).init(.{ 0.4, 0.6 }, .{ .nyquist = 3.0, .window = WindowFunction.Bartlett });
        var tester = try BlockTester(&[1]type{f32}, &[1]type{f32}).init(&block.block, 1e-6);
        try tester.check(2, .{&vectors.input_float32}, .{&vectors.output_taps_129_cutoff_0_4_0_6_nyquist_3_0_window_bartlett_float32}, .{});
    }
}
