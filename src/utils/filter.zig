const std = @import("std");

const WindowFunction = @import("./window.zig").WindowFunction;
const window = @import("./window.zig").window;

////////////////////////////////////////////////////////////////////////////////
// FIR Filter Functions
////////////////////////////////////////////////////////////////////////////////

// Causal FIR filters computed from truncations of ideal IIR filters
//
// See http://www.labbookpages.co.uk/audio/firWindowing.html for derivations.

pub fn firLowpass(comptime N: comptime_int, cutoff: f32) [N]f32 {
    var h: [N]f32 = undefined;

    for (h) |_, i| {
        if (N % 2 == 1 and i == (N - 1) / 2) {
            h[i] = cutoff;
        } else {
            const arg = @intToFloat(f32, i) - ((@intToFloat(f32, N) - 1) / 2);
            h[i] = std.math.sin(std.math.pi * cutoff * arg) / (std.math.pi * arg);
        }
    }

    return h;
}

pub fn firHighpass(comptime N: comptime_int, cutoff: f32) [N]f32 {
    var h: [N]f32 = undefined;

    std.debug.assert((N % 2) == 1);

    for (h) |_, i| {
        if (i == (N - 1) / 2) {
            h[i] = 1 - cutoff;
        } else {
            const arg = @intToFloat(f32, i) - ((@intToFloat(f32, N) - 1) / 2);
            h[i] = -std.math.sin(std.math.pi * cutoff * arg) / (std.math.pi * arg);
        }
    }

    return h;
}

pub fn firBandpass(comptime N: comptime_int, cutoffs: std.meta.Tuple(&[2]type{ f32, f32 })) [N]f32 {
    var h: [N]f32 = undefined;

    std.debug.assert((N % 2) == 1);

    for (h) |_, i| {
        if (i == (N - 1) / 2) {
            h[i] = cutoffs[1] - cutoffs[0];
        } else {
            const arg = @intToFloat(f32, i) - ((@intToFloat(f32, N) - 1) / 2);
            h[i] = std.math.sin(std.math.pi * cutoffs[1] * arg) / (std.math.pi * arg) - std.math.sin(std.math.pi * cutoffs[0] * arg) / (std.math.pi * arg);
        }
    }

    return h;
}

pub fn firBandstop(comptime N: comptime_int, cutoffs: std.meta.Tuple(&[2]type{ f32, f32 })) [N]f32 {
    var h: [N]f32 = undefined;

    std.debug.assert((N % 2) == 1);

    for (h) |_, i| {
        if (i == (N - 1) / 2) {
            h[i] = 1 - (cutoffs[1] - cutoffs[0]);
        } else {
            const arg = @intToFloat(f32, i) - ((@intToFloat(f32, N) - 1) / 2);
            h[i] = std.math.sin(std.math.pi * cutoffs[0] * arg) / (std.math.pi * arg) - std.math.sin(std.math.pi * cutoffs[1] * arg) / (std.math.pi * arg);
        }
    }

    return h;
}

////////////////////////////////////////////////////////////////////////////////
// FIR Windowing
////////////////////////////////////////////////////////////////////////////////

// FIR window method filter design
//
// See http://www.labbookpages.co.uk/audio/firWindowing.html for derivations.

pub fn firwin(comptime N: comptime_int, h: [N]f32, window_func: WindowFunction, scale_freq: f32) [N]f32 {
    var hw: [N]f32 = undefined;

    // Generate and apply window
    const w = window(N, window_func, false);
    for (hw) |_, i| {
        hw[i] = h[i] * w[i];
    }

    // Scale magnitude response
    var scale: f32 = 0;
    for (hw) |_, i| {
        const arg = @intToFloat(f32, i) - ((@intToFloat(f32, N) - 1) / 2);
        scale += hw[i] * std.math.cos(std.math.pi * arg * scale_freq);
    }
    for (hw) |*e| {
        e.* /= scale;
    }

    return hw;
}

////////////////////////////////////////////////////////////////////////////////
// Top-level Firwin Filters
////////////////////////////////////////////////////////////////////////////////

pub fn firwinLowpass(comptime N: comptime_int, cutoff: f32, window_func: WindowFunction) [N]f32 {
    // Generate truncated lowpass filter taps
    const h = firLowpass(N, cutoff);
    // Apply window and scale by DC gain
    return firwin(N, h, window_func, 0.0);
}

pub fn firwinHighpass(comptime N: comptime_int, cutoff: f32, window_func: WindowFunction) [N]f32 {
    // Generate truncated highpass filter taps
    const h = firHighpass(N, cutoff);
    // Apply window and scale by Nyquist gain
    return firwin(N, h, window_func, 1.0);
}

pub fn firwinBandpass(comptime N: comptime_int, cutoffs: std.meta.Tuple(&[2]type{ f32, f32 }), window_func: WindowFunction) [N]f32 {
    // Generate truncated bandpass filter taps
    const h = firBandpass(N, cutoffs);
    // Apply window and scale by passband gain
    return firwin(N, h, window_func, (cutoffs[0] + cutoffs[1]) / 2);
}

pub fn firwinBandstop(comptime N: comptime_int, cutoffs: std.meta.Tuple(&[2]type{ f32, f32 }), window_func: WindowFunction) [N]f32 {
    // Generate truncated bandpass filter taps
    const h = firBandstop(N, cutoffs);
    // Apply window and scale by DC gain
    return firwin(N, h, window_func, 0.0);
}

////////////////////////////////////////////////////////////////////////////////
// Tests
////////////////////////////////////////////////////////////////////////////////

const expectEqualVectors = @import("radio").testing.expectEqualVectors;

test "firwin" {
    try expectEqualVectors(f32, &[128]f32{ -0.00028372, -0.00029029, 0.00030119, 0.00031662, -0.00033678, -0.00036188, 0.00039212, 0.00042773, -0.00046892, -0.00051591, 0.00056894, 0.00062823, -0.00069404, -0.00076662, 0.00084622, 0.00093314, -0.00102764, -0.00113004, 0.00124066, 0.00135983, -0.00148792, -0.00162531, 0.00177242, 0.00192970, -0.00209763, -0.00227676, 0.00246765, 0.00267095, -0.00288736, -0.00311768, 0.00336277, 0.00362363, -0.00390134, -0.00419716, 0.00451250, 0.00484899, -0.00520847, -0.00559309, 0.00600531, 0.00644804, -0.00692467, -0.00743918, 0.00799635, 0.00860188, -0.00926263, -0.00998702, 0.01078536, 0.01167052, -0.01265868, -0.01377056, 0.01503300, 0.01648152, -0.01816398, -0.02014658, 0.02252340, 0.02543288, -0.02908737, -0.03382997, 0.04025342, 0.04947747, -0.06390175, -0.08976559, 0.14994681, 0.45034730, 0.45034730, 0.14994681, -0.08976559, -0.06390175, 0.04947747, 0.04025342, -0.03382997, -0.02908737, 0.02543288, 0.02252340, -0.02014658, -0.01816398, 0.01648152, 0.01503300, -0.01377056, -0.01265868, 0.01167052, 0.01078536, -0.00998702, -0.00926263, 0.00860188, 0.00799635, -0.00743918, -0.00692467, 0.00644804, 0.00600531, -0.00559309, -0.00520847, 0.00484899, 0.00451250, -0.00419716, -0.00390134, 0.00362363, 0.00336277, -0.00311768, -0.00288736, 0.00267095, 0.00246765, -0.00227676, -0.00209763, 0.00192970, 0.00177242, -0.00162531, -0.00148792, 0.00135983, 0.00124066, -0.00113004, -0.00102764, 0.00093314, 0.00084622, -0.00076662, -0.00069404, 0.00062823, 0.00056894, -0.00051591, -0.00046892, 0.00042773, 0.00039212, -0.00036188, -0.00033678, 0.00031662, 0.00030119, -0.00029029, -0.00028372 }, &firwinLowpass(128, 0.5, WindowFunction.Hamming), 0, 1e-6, false);
    try expectEqualVectors(f32, &[129]f32{ -0.00000000, 0.00040716, -0.00000000, -0.00044361, -0.00000000, 0.00050618, 0.00000000, -0.00059715, -0.00000000, 0.00071888, -0.00000000, -0.00087386, 0.00000000, 0.00106473, 0.00000000, -0.00129429, -0.00000000, 0.00156564, -0.00000000, -0.00188216, -0.00000000, 0.00224766, 0.00000000, -0.00266651, -0.00000000, 0.00314378, -0.00000000, -0.00368550, -0.00000000, 0.00429892, 0.00000000, -0.00499296, -0.00000000, 0.00577880, -0.00000000, -0.00667063, -0.00000000, 0.00768693, 0.00000000, -0.00885212, -0.00000000, 0.01019929, -0.00000000, -0.01177435, -0.00000000, 0.01364282, -0.00000000, -0.01590150, -0.00000000, 0.01869934, -0.00000000, -0.02227765, -0.00000000, 0.02705416, -0.00000000, -0.03381911, -0.00000000, 0.04426758, -0.00000000, -0.06280917, -0.00000000, 0.10561675, -0.00000000, -0.31825924, 0.50019759, -0.31825924, -0.00000000, 0.10561675, -0.00000000, -0.06280917, -0.00000000, 0.04426758, -0.00000000, -0.03381911, -0.00000000, 0.02705416, -0.00000000, -0.02227765, -0.00000000, 0.01869934, -0.00000000, -0.01590150, -0.00000000, 0.01364282, -0.00000000, -0.01177435, -0.00000000, 0.01019929, -0.00000000, -0.00885212, 0.00000000, 0.00768693, -0.00000000, -0.00667063, -0.00000000, 0.00577880, -0.00000000, -0.00499296, 0.00000000, 0.00429892, -0.00000000, -0.00368550, -0.00000000, 0.00314378, -0.00000000, -0.00266651, 0.00000000, 0.00224766, -0.00000000, -0.00188216, -0.00000000, 0.00156564, -0.00000000, -0.00129429, 0.00000000, 0.00106473, 0.00000000, -0.00087386, -0.00000000, 0.00071888, -0.00000000, -0.00059715, 0.00000000, 0.00050618, -0.00000000, -0.00044361, -0.00000000, 0.00040716, -0.00000000 }, &firwinHighpass(129, 0.5, WindowFunction.Hamming), 0, 1e-6, false);
    try expectEqualVectors(f32, &[129]f32{ 0.00075680, -0.00000000, -0.00049618, -0.00000000, -0.00000000, 0.00000000, 0.00064390, -0.00000000, -0.00124347, 0.00000000, 0.00150592, -0.00000000, -0.00113351, 0.00000000, -0.00000000, 0.00000000, 0.00167392, -0.00000000, -0.00326645, 0.00000000, 0.00391384, -0.00000000, -0.00287903, 0.00000000, -0.00000000, 0.00000000, 0.00400244, -0.00000000, -0.00757230, 0.00000000, 0.00881288, -0.00000000, -0.00631429, 0.00000000, -0.00000000, 0.00000000, 0.00841560, -0.00000000, -0.01568386, 0.00000000, 0.01806306, -0.00000000, -0.01287253, 0.00000000, -0.00000000, -0.00000000, 0.01729172, -0.00000000, -0.03274160, 0.00000000, 0.03872998, -0.00000000, -0.02876437, -0.00000000, -0.00000000, 0.00000000, 0.04513478, -0.00000000, -0.09890740, 0.00000000, 0.15002130, -0.00000000, -0.18667576, -0.00000000, 0.19999178, -0.00000000, -0.18667576, -0.00000000, 0.15002130, 0.00000000, -0.09890740, -0.00000000, 0.04513478, 0.00000000, -0.00000000, -0.00000000, -0.02876437, -0.00000000, 0.03872998, 0.00000000, -0.03274160, -0.00000000, 0.01729172, -0.00000000, -0.00000000, 0.00000000, -0.01287253, -0.00000000, 0.01806306, 0.00000000, -0.01568386, -0.00000000, 0.00841560, 0.00000000, -0.00000000, 0.00000000, -0.00631429, -0.00000000, 0.00881288, 0.00000000, -0.00757230, -0.00000000, 0.00400244, 0.00000000, -0.00000000, 0.00000000, -0.00287903, -0.00000000, 0.00391384, 0.00000000, -0.00326645, -0.00000000, 0.00167392, 0.00000000, -0.00000000, 0.00000000, -0.00113351, -0.00000000, 0.00150592, 0.00000000, -0.00124347, -0.00000000, 0.00064390, 0.00000000, -0.00000000, -0.00000000, -0.00049618, -0.00000000, 0.00075680 }, &firwinBandpass(129, .{ 0.4, 0.6 }, WindowFunction.Hamming), 0, 1e-6, false);
    try expectEqualVectors(f32, &[129]f32{ -0.00075745, 0.00000000, 0.00049661, 0.00000000, -0.00000000, 0.00000000, -0.00064445, 0.00000000, 0.00124455, -0.00000000, -0.00150723, 0.00000000, 0.00113449, 0.00000000, 0.00000000, 0.00000000, -0.00167537, -0.00000000, 0.00326927, -0.00000000, -0.00391722, 0.00000000, 0.00288152, 0.00000000, -0.00000000, 0.00000000, -0.00400590, 0.00000000, 0.00757885, 0.00000000, -0.00882050, 0.00000000, 0.00631975, 0.00000000, -0.00000000, 0.00000000, -0.00842288, 0.00000000, 0.01569741, -0.00000000, -0.01807867, 0.00000000, 0.01288365, -0.00000000, -0.00000000, 0.00000000, -0.01730667, 0.00000000, 0.03276990, 0.00000000, -0.03876346, -0.00000000, 0.02878923, 0.00000000, -0.00000000, 0.00000000, -0.04517380, 0.00000000, 0.09899289, 0.00000000, -0.15015098, 0.00000000, 0.18683712, 0.00000000, 0.80065864, 0.00000000, 0.18683712, 0.00000000, -0.15015098, 0.00000000, 0.09899289, 0.00000000, -0.04517380, 0.00000000, -0.00000000, 0.00000000, 0.02878923, -0.00000000, -0.03876346, 0.00000000, 0.03276990, 0.00000000, -0.01730667, 0.00000000, -0.00000000, -0.00000000, 0.01288365, 0.00000000, -0.01807867, -0.00000000, 0.01569741, 0.00000000, -0.00842288, 0.00000000, -0.00000000, 0.00000000, 0.00631975, 0.00000000, -0.00882050, 0.00000000, 0.00757885, 0.00000000, -0.00400590, 0.00000000, -0.00000000, 0.00000000, 0.00288152, 0.00000000, -0.00391722, -0.00000000, 0.00326927, -0.00000000, -0.00167537, 0.00000000, 0.00000000, 0.00000000, 0.00113449, 0.00000000, -0.00150723, -0.00000000, 0.00124455, 0.00000000, -0.00064445, 0.00000000, -0.00000000, 0.00000000, 0.00049661, 0.00000000, -0.00075745 }, &firwinBandstop(129, .{ 0.4, 0.6 }, WindowFunction.Hamming), 0, 1e-6, false);
}
